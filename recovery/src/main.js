import { s as D } from "./leaderboard.js"; const y = 10, v = 20, c = 30, a = { LEFT: "ArrowLeft", RIGHT: "ArrowRight", DOWN: "ArrowDown", UP: "ArrowUp", SPACE: " ", ESC: "Escape", P: "p" }, x = ["none", "cyan", "blue", "orange", "yellow", "green", "purple", "red"], R = [[], [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]], [[2, 0, 0], [2, 2, 2], [0, 0, 0]], [[0, 0, 3], [3, 3, 3], [0, 0, 0]], [[4, 4], [4, 4]], [[0, 5, 5], [5, 5, 0], [0, 0, 0]], [[0, 6, 0], [6, 6, 6], [0, 0, 0]], [[7, 7, 0], [0, 7, 7], [0, 0, 0]]]; function b(n, e, t, i) { const s = e * c, o = t * c; n.fillStyle = i, n.fillRect(s, o, c, c), n.lineWidth = 2, n.strokeStyle = "rgba(255, 255, 255, 0.5)", n.beginPath(), n.moveTo(s, o + c), n.lineTo(s, o), n.lineTo(s + c, o), n.stroke(), n.strokeStyle = "rgba(0, 0, 0, 0.5)", n.beginPath(), n.moveTo(s + c, o), n.lineTo(s + c, o + c), n.lineTo(s, o + c), n.stroke(), n.fillStyle = "rgba(0, 0, 0, 0.1)", n.fillRect(s + 4, o + 4, c - 8, c - 8) } class w { constructor(e) { this.ctx = e, this.grid = this.getEmptyGrid() } getEmptyGrid() { return Array.from({ length: v }, () => Array(y).fill(0)) } valid(e) { return e.shape.every((t, i) => t.every((s, o) => { let h = e.x + o, r = e.y + i; return s === 0 || this.isInsideWalls(h, r) && this.notOccupied(h, r) })) } isInsideWalls(e, t) { return e >= 0 && e < y && t <= v } notOccupied(e, t) { return this.grid[t] && this.grid[t][e] === 0 } rotate(e) { let t = JSON.parse(JSON.stringify(e)); for (let i = 0; i < t.shape.length; ++i)for (let s = 0; s < i; ++s) [t.shape[s][i], t.shape[i][s]] = [t.shape[i][s], t.shape[s][i]]; return t.shape.forEach(i => i.reverse()), t } draw() { this.grid.forEach((e, t) => { e.forEach((i, s) => { i > 0 && b(this.ctx, s, t, x[i]) }) }) } freeze(e) { e.shape.forEach((t, i) => { t.forEach((s, o) => { s > 0 && (this.grid[e.y + i][e.x + o] = s) }) }) } } class I { constructor(e) { this.ctx = e, this.spawn() } spawn() { this.typeId = this.randomizeTetrominoType(x.length - 1), this.shape = R[this.typeId], this.color = x[this.typeId], this.x = 0, this.y = 0, this.x = 3 } randomizeTetrominoType(e) { return Math.floor(Math.random() * e + 1) } move(e) { this.x = e.x, this.y = e.y, this.shape = e.shape } draw(e = null, t = null, i = null) { const s = e !== null ? e : this.x, o = t !== null ? t : this.y, h = i !== null ? i : this.color; this.shape.forEach((r, d) => { r.forEach((l, m) => { l > 0 && b(this.ctx, s + m, o + d, h) }) }) } } class W { constructor() { this.ctx = new (window.AudioContext || window.webkitAudioContext), this.masterGain = this.ctx.createGain(), this.masterGain.gain.value = .3, this.masterGain.connect(this.ctx.destination), this.isMuted = !1, document.addEventListener("keydown", () => { this.ctx.state === "suspended" && this.ctx.resume() }, { once: !0 }), document.addEventListener("click", () => { this.ctx.state === "suspended" && this.ctx.resume() }, { once: !0 }) } toggleMute() { return this.isMuted = !this.isMuted, this.masterGain.gain.value = this.isMuted ? 0 : .3, this.isMuted } playTone(e, t, i) { if (this.ctx.state === "suspended") return; const s = this.ctx.createOscillator(), o = this.ctx.createGain(); s.type = t, s.frequency.setValueAtTime(e, this.ctx.currentTime), o.gain.setValueAtTime(this.masterGain.gain.value, this.ctx.currentTime), o.gain.exponentialRampToValueAtTime(.01, this.ctx.currentTime + i), s.connect(o), o.connect(this.ctx.destination), s.start(), s.stop(this.ctx.currentTime + i) } move() { this.playTone(200, "triangle", .1) } rotate() { this.playTone(400, "sine", .1) } drop() { this.playTone(100, "square", .15) } clear() { this.playTone(400, "sine", .1), setTimeout(() => this.playTone(500, "sine", .1), 100), setTimeout(() => this.playTone(600, "sine", .1), 200), setTimeout(() => this.playTone(800, "sine", .2), 300) } gameOver() { this.playTone(100, "sawtooth", 1), this.stopMusic() } async startMusic(e = 0) { this.ctx.state === "suspended" && await this.ctx.resume(), this.stopMusic(); const t = [{ title: "Classic Pop", tempo: 400, notes: [{ f: 261.63, d: 2 }, { f: 392, d: 2 }, { f: 440, d: 2 }, { f: 349.23, d: 2 }, { f: 261.63, d: 1 }, { f: 293.66, d: 1 }, { f: 329.63, d: 2 }, { f: 392, d: 2 }, { f: 349.23, d: 2 }] }, { title: "Minor Dance", tempo: 300, notes: [{ f: 440, d: 1 }, { f: 440, d: 1 }, { f: 349.23, d: 2 }, { f: 261.63, d: 1 }, { f: 392, d: 3 }, { f: 523.25, d: 1 }, { f: 493.88, d: 1 }, { f: 440, d: 2 }] }, { title: "Power Ballad", tempo: 600, notes: [{ f: 261.63, d: 4 }, { f: 329.63, d: 4 }, { f: 349.23, d: 4 }, { f: 392, d: 4 }] }], i = e % t.length, s = t[i]; this.currentSongTitle = s.title; let o = Math.floor(e / t.length), h = Math.max(.5, 1 - o * .1), r = s.tempo * h, d = 0; const l = () => { const m = s.notes[d]; this.playTone(m.f, "triangle", r * m.d * 8e-4), d = (d + 1) % s.notes.length, this.musicInterval = setTimeout(l, r * m.d) }; l() } stopMusic() { this.musicInterval && (clearTimeout(this.musicInterval), this.musicInterval = null) } } class X {
    constructor(e, t) { this.ctx = e, this.ctxNext = t, this.board = new w(e), this.audio = new W, this.piece = null, this.nextPieces = [] } play() { this.reset(), this.loop(); const e = '<path d="M23 4v6h-6"/><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"/>', t = document.getElementById("mob-restart-icon"); t && (t.innerHTML = e) } reset() { this.requestId && (cancelAnimationFrame(this.requestId), this.requestId = null), this.board = new w(this.ctx), this.score = 0, this.lines = 0, this.level = 0, this.time = { start: 0, elapsed: 0, level: 1e3 }, this.speedManualOffset = 0, this.totalTime = 0, this.lastTime = 0, this.gameOver = !1, this.isPaused = !1, this.effects = []; const e = document.getElementById("pause-btn"); e && (e.innerText = "Pause", e.classList.remove("paused")), this.nextPieces = [], this.piece = this.getNextPiece(), this.audio.startMusic(this.level), this.updateAccount() } getNextPiece() { for (; this.nextPieces.length < 2;)this.nextPieces.push(new I(this.ctx)); const e = this.nextPieces.shift(); return this.nextPieces.push(new I(this.ctx)), e } togglePause() { if (this.gameOver) return; this.isPaused = !this.isPaused; const e = document.getElementById("pause-btn"); e && (e.innerText = this.isPaused ? "Resume" : "Pause", e.classList.toggle("paused", this.isPaused)), this.isPaused ? this.audio.stopMusic() : (this.audio.startMusic(this.level), this.lastTime = 0, this.loop()) } loop(e = 0) { if (this.isPaused) return; this.lastTime || (this.lastTime = e); const t = e - this.lastTime; this.lastTime = e, this.totalTime += t, this.time.elapsed = e - this.time.start, this.time.elapsed > this.time.level && (this.time.start = e, this.drop()), !this.gameOver && (this.draw(), this.requestId = requestAnimationFrame(this.loop.bind(this))) } drop() { let e = this.moves[a.DOWN](this.piece); if (this.board.valid(e)) this.piece.move(e); else { if (this.board.freeze(this.piece), this.board.grid[0].some(t => t > 0)) { this.handleGameOver(); return } this.clearLines(), this.piece = this.getNextPiece(), this.board.valid(this.piece) || this.handleGameOver() } } handleGameOver() {
        this.gameOver = !0, this.audio.gameOver(), this.updateAccount(); const e = document.getElementById("username"), t = e && e.value ? e.value : `Player ${Date.now()}`; D(t, this.score, this.totalTime, this.level), setTimeout(() => {
            alert(`Game Over! Score: ${this.score}
Saved for ${t}.`), window.location.href = "ranking.html"
        }, 100)
    } clearLines() { let e = 0; const t = []; if (this.board.grid.forEach((i, s) => { i.every(o => o > 0) && t.push({ y: s, row: [...i] }) }), t.length > 0) { const i = Date.now(); t.forEach(s => { this.effects.push({ type: "line-clear", y: s.y, blocks: s.row, startTime: i, duration: 2e3 }) }) } for (this.board.grid = this.board.grid.reduce((i, s) => s.every(o => o > 0) ? (e++, i) : (i.push(s), i), []); this.board.grid.length < v;)this.board.grid.unshift(Array(y).fill(0)); if (e > 0) { const i = [0, 40, 100, 300, 1200]; this.score += Number(i[e] * (this.level + 1)), this.lines += e, this.audio.clear(), this.checkLevel(), this.updateAccount() } } handleWheel(e) { const t = e.deltaY > 0 ? 50 : -50; this.speedManualOffset += t, this.updateSpeed(), this.updateAccount() } calculateBaseSpeed() { return Math.max(100, 1e3 - this.level * 50) } updateSpeed() { const e = this.calculateBaseSpeed(); this.time.level = Math.max(50, e + this.speedManualOffset) } checkLevel() { const e = this.lines; e > this.level && (this.level = e, this.updateSpeed(), this.audio.startMusic(this.level)) } updateAccount() { document.getElementById("score").innerText = this.score, document.getElementById("lines").innerText = this.lines, document.getElementById("level").innerText = this.level; let e = 0; this.time && this.time.level && (e = Math.min(100, Math.round((1e3 - this.time.level) / 900 * 100))), isNaN(e) && (e = 0), document.getElementById("speed").innerText = e + "%", this.audio.currentSongTitle && (document.getElementById("song-title").innerText = this.audio.currentSongTitle); const t = document.getElementById("mob-score"); t && (t.innerText = this.score, document.getElementById("mob-lines").innerText = this.lines, document.getElementById("mob-level").innerText = this.level, document.getElementById("mob-speed").innerText = e + "%", document.getElementById("mob-song-title").innerText = this.audio.currentSongTitle || "None") } getGhostPosition() { if (!this.piece) return null; let e = { ...this.piece }; for (; ;) { let t = this.moves[a.DOWN](e); if (!this.board.valid(t)) break; e.x = t.x, e.y = t.y, e.shape = t.shape } return e } draw() { this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height), this.board.draw(), this.drawEffects(); const e = this.getGhostPosition(); e && e.y > this.piece.y && this.piece.draw(e.x, e.y, "rgba(255, 255, 255, 0.3)"), this.piece.draw(), this.drawNext() } drawEffects() { const e = Date.now(); this.effects = this.effects.filter(t => e - t.startTime < t.duration), this.effects.forEach(t => { if (t.type === "line-clear") { const i = e - t.startTime, s = Math.min(1, i / t.duration); this.ctx.fillStyle = `rgba(144, 238, 144, ${1 - s})`, this.ctx.fillRect(0, t.y * c, this.ctx.canvas.width, c), t.blocks.forEach((o, h) => { if (o > 0) { const r = x[o], d = (Math.random() - .5) * 10 * s, l = (Math.random() - .5) * 10 * s; this.ctx.save(), this.ctx.globalAlpha = 1 - s, this.ctx.translate(d, l), b(this.ctx, h, t.y, r), this.ctx.restore() } }) } }) } drawNext() { !this.nextPieces || this.nextPieces.length === 0 || (this.ctxNext.clearRect(0, 0, this.ctxNext.canvas.width, this.ctxNext.canvas.height), this.renderPieceOnCanvas(this.ctxNext, this.nextPieces[0], 0, 0), this.mobCtxNext && (this.mobCtxNext.clearRect(0, 0, 120, 40), this.renderPieceOnCanvas(this.mobCtxNext, this.nextPieces[0], 0, 0), this.mobCtxNext.save(), this.mobCtxNext.translate(60, 0), this.renderPieceOnCanvas(this.mobCtxNext, this.nextPieces[1], 0, 0), this.mobCtxNext.restore())) } renderPieceOnCanvas(e, t, i = 0, s = 0) { t && t.shape.forEach((o, h) => { o.forEach((r, d) => { r > 0 && b(e, d + .5 + i, h + .5 + s, t.color) }) }) } handleClick(e) { if (this.isPaused || this.gameOver || !this.piece) return; const t = this.ctx.canvas.getBoundingClientRect(), i = this.ctx.canvas.width / t.width, s = this.ctx.canvas.height / t.height, o = (e.clientX - t.left) * i, h = (e.clientY - t.top) * s, r = Math.floor(o / c), d = Math.floor(h / c), l = this.getGhostPosition(); if (l && l.shape.some((S, L) => S.some((C, N) => { if (C > 0) { const A = l.x + N, G = l.y + L; return A === r && G === d } return !1 }))) { this.handleInput({ key: a.SPACE, preventDefault: () => { } }); return } const m = this.moves[a.UP](this.piece); this.board.valid(m) && (this.audio.rotate(), this.piece.move(m)) } handleMouseMove(e) { if (this.isPaused || this.gameOver || !this.piece) return; const t = this.ctx.canvas.getBoundingClientRect(), i = this.ctx.canvas.width / t.width, s = (e.clientX - t.left) * i, o = Math.floor(s / c), h = this.piece.shape[0].length; let r = o - Math.floor(h / 2); const d = { ...this.piece, x: r }; this.board.valid(d) && this.piece.x !== r && (this.audio.move(), this.piece.move(d)) } handleInput(e) { if (console.log("Key:", e.key, "Paused:", this.isPaused, "GameOver:", this.gameOver, "Piece:", !!this.piece), this.gameOver) { e.key === "Enter" && this.play(); return } if (e.key === a.P || e.key === a.ESC) { this.togglePause(); return } if (!this.isPaused && this.piece && this.moves[e.key]) { e.preventDefault(); let t = this.moves[e.key](this.piece); if (e.key === a.SPACE) { for (; this.board.valid(t);)this.piece.move(t), t = this.moves[a.DOWN](this.piece); if (this.audio.drop(), this.board.freeze(this.piece), this.board.grid[0].some(i => i > 0)) { this.handleGameOver(); return } this.clearLines(), this.piece = this.getNextPiece(), this.board.valid(this.piece) || this.handleGameOver() } else this.board.valid(t) && (e.key === a.UP ? this.audio.rotate() : (e.key === a.LEFT || e.key === a.RIGHT || e.key === a.DOWN) && this.audio.move(), this.piece.move(t)) } } moves = { [a.LEFT]: e => ({ ...e, x: e.x - 1 }), [a.RIGHT]: e => ({ ...e, x: e.x + 1 }), [a.DOWN]: e => ({ ...e, y: e.y + 1 }), [a.UP]: e => this.board.rotate(e), [a.SPACE]: e => ({ ...e, y: e.y + 1 }) }; handleTouchStart(e) { if (this.isPaused || this.gameOver || !this.piece) return; e.preventDefault(), this.touchFingerCount = e.touches.length; const t = e.changedTouches[0]; this.touchStartX = t.clientX, this.touchStartY = t.clientY, this.touchStartTime = Date.now() } handleTouchEnd(e) { if (this.isPaused || this.gameOver || !this.piece) return; e.preventDefault(); const t = e.changedTouches[0], i = t.clientX - this.touchStartX, s = t.clientY - this.touchStartY, o = Date.now() - this.touchStartTime, h = Math.abs(i), r = Math.abs(s), d = this.touchFingerCount >= 2 ? 4 : 1; if (o < 300 && h < 10 && r < 10) { const l = this.moves[a.UP](this.piece); this.board.valid(l) && (this.audio.rotate(), this.piece.move(l)); return } if (h > r) { if (h > 30) { const l = i > 0 ? a.RIGHT : a.LEFT; this.audio.move(); for (let m = 0; m < d; m++) { const T = this.moves[l](this.piece); if (this.board.valid(T)) this.piece.move(T); else break } } } else if (r > 30) if (s > 0) { this.audio.move(); for (let l = 0; l < d; l++) { const m = this.moves[a.DOWN](this.piece); if (this.board.valid(m)) this.piece.move(m), this.score += 1; else break } this.updateAccount() } else this.handleInput({ key: a.SPACE, preventDefault: () => { } }) }
} const p = document.getElementById("board"), k = p.getContext("2d"); p.width = y * c; p.height = v * c; k.scale(1, 1); p.addEventListener("click", n => { u.handleClick(n), n.preventDefault() }); p.addEventListener("mousemove", n => { u.handleMouseMove(n) }); p.addEventListener("touchstart", n => { u.handleTouchStart(n) }, { passive: !1 }); p.addEventListener("touchend", n => { u.handleTouchEnd(n) }, { passive: !1 }); const P = document.getElementById("next"), B = P.getContext("2d"); P.width = 4 * c; P.height = 4 * c; B.scale(1, 1); const u = new X(k, B), E = document.getElementById("play-btn"); E && E.addEventListener("click", () => { u.play(), E.blur(), window.focus() }); const f = document.getElementById("pause-btn"); f && (f.classList.remove("paused"), f.addEventListener("click", () => { u.togglePause(), f.blur() })); const M = document.getElementById("mob-menu-btn"); if (M) { const n = document.getElementById("mob-menu-overlay"), e = document.getElementById("mob-menu-close"); M.addEventListener("click", () => { n.style.display = "flex", u.isPaused = !0 }), e.addEventListener("click", () => { n.style.display = "none", u.isPaused = !1, u.loop() }); const t = document.getElementById("mob-play-btn"); t && t.addEventListener("click", () => { u.play(), n.style.display = "none" }); const i = document.getElementById("mob-pause-btn"); i && i.addEventListener("click", () => { u.togglePause() }); const s = document.getElementById("mob-restart-btn"); s && s.addEventListener("click", () => { confirm("Restart Game?") && (u.play(), s.blur()) }); const o = document.getElementById("mob-mute-btn"); if (o) { const h = document.getElementById("mob-mute-icon"); o.addEventListener("click", () => { u.audio.toggleMute() ? h.innerHTML = '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"/><line x1="17" y1="9" x2="23" y2="15"/>' : h.innerHTML = '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"/>', o.blur() }) } } const O = document.getElementById("mob-next"); if (O) { const n = O.getContext("2d"); n.scale(.5, .5), u.mobCtxNext = n } document.addEventListener("wheel", n => { u.handleWheel(n) }, { passive: !0 }); const g = document.getElementById("username"); if (g) { g.value = `Player ${Date.now()}`; const n = document.getElementById("mob-username"); n && (n.value = g.value), n.addEventListener("input", e => { g.value = e.target.value }) } document.addEventListener("keydown", n => { u.handleInput(n) });
